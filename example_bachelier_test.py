#!/usr/bin/env python3
"""
Example: Testing Bachelier Model in Deep Hedging
===============================================

This script demonstrates the new Bachelier model capability in the Deep Hedging framework.
The Bachelier model uses arithmetic Brownian motion (normal distribution) instead of 
geometric Brownian motion (log-normal distribution) like Black-Scholes.

Key differences:
- Asset evolution: dS = μ dt + σ dW (can go negative)
- Option pricing: Bachelier formula instead of Black-Scholes
- Greeks: Bachelier delta and vega formulas

Author: AI Assistant
Created: 2024
"""

import numpy as np
import matplotlib.pyplot as plt
from deephedging.base import Config
from deephedging.world import SimpleWorld_Spot_ATM
from deephedging.gym import VanillaDeepHedgingGym
from deephedging.trainer import train

def create_worlds_comparison():
    """Create worlds using different models for comparison."""
    
    # Common configuration
    base_config = Config()
    base_config.samples = 1000
    base_config.steps = 20
    base_config.dt = 1/50
    base_config.seed = 12345
    base_config.strike = 1.0  # ATM option
    base_config.rvol = 0.2    # 20% volatility
    base_config.ivol = 0.2
    base_config.drift = 0.05  # 5% drift
    
    # Turn off stochastic features for cleaner comparison
    base_config.no_stoch_vol = True
    base_config.no_stoch_drift = True
    
    print("Creating worlds for comparison...")
    
    # 1. Default (Geometric Brownian Motion / Black-Scholes)
    config_bs = base_config.copy()
    world_bs = SimpleWorld_Spot_ATM(config_bs)
    
    # 2. Bachelier (Arithmetic Brownian Motion)
    config_bachelier = base_config.copy() 
    config_bachelier.bachelier = True
    world_bachelier = SimpleWorld_Spot_ATM(config_bachelier)
    
    # 3. Pure Black-Scholes mode (no options)
    config_bs_pure = base_config.copy()
    config_bs_pure.black_scholes = True
    world_bs_pure = SimpleWorld_Spot_ATM(config_bs_pure)
    
    return {
        'Black-Scholes': world_bs,
        'Bachelier': world_bachelier, 
        'BS Pure': world_bs_pure
    }

def compare_spot_paths(worlds):
    """Compare spot price paths generated by different models."""
    
    print("\nComparing spot price paths...")
    
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    fig.suptitle('Model Comparison: Spot Price Paths', fontsize=16)
    
    for i, (name, world) in enumerate(worlds.items()):
        if i >= 3:  # Only plot first 3
            break
            
        ax = axes[i//2, i%2]
        
        # Plot first 10 paths
        for j in range(min(10, world.nSamples)):
            ax.plot(world.timeline, world.details.spot_all[j, :], alpha=0.7, linewidth=0.8)
        
        # Plot mean path
        mean_path = np.mean(world.details.spot_all, axis=0)
        ax.plot(world.timeline, mean_path, 'k-', linewidth=2, label='Mean')
        
        ax.set_title(f'{name} Model')
        ax.set_xlabel('Time')
        ax.set_ylabel('Spot Price')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Print statistics
        final_spots = world.details.spot_all[:, -1]
        print(f"{name}:")
        print(f"  Final spot mean: {np.mean(final_spots):.4f}")
        print(f"  Final spot std:  {np.std(final_spots):.4f}")
        print(f"  Min spot: {np.min(world.details.spot_all):.4f}")
        print(f"  Max spot: {np.max(world.details.spot_all):.4f}")
        
        # Check for negative prices (only possible in Bachelier)
        if np.any(world.details.spot_all < 0):
            neg_count = np.sum(world.details.spot_all < 0)
            print(f"  Negative prices: {neg_count} occurrences")
    
    # Remove empty subplot
    if len(worlds) < 4:
        axes[1, 1].remove()
    
    plt.tight_layout()
    plt.show()

def compare_option_pricing(worlds):
    """Compare option prices and Greeks between models."""
    
    print("\nComparing option pricing...")
    
    # Only compare models that have options
    option_worlds = {name: world for name, world in worlds.items() 
                    if world.nInst > 1}
    
    if len(option_worlds) == 0:
        print("No worlds with options to compare")
        return
    
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    fig.suptitle('Model Comparison: Option Pricing', fontsize=16)
    
    for i, (name, world) in enumerate(option_worlds.items()):
        # Option prices over time (first sample)
        ax1 = axes[0, i]
        option_prices = world.data.features.per_step.call_price[0, :]  # First sample
        ax1.plot(range(world.nSteps), option_prices, 'b-', linewidth=2)
        ax1.set_title(f'{name}: Option Prices')
        ax1.set_xlabel('Time Step')
        ax1.set_ylabel('Option Price')
        ax1.grid(True, alpha=0.3)
        
        # Option deltas over time (first sample)
        ax2 = axes[1, i]
        option_deltas = world.data.features.per_step.call_delta[0, :]  # First sample
        ax2.plot(range(world.nSteps), option_deltas, 'r-', linewidth=2)
        ax2.set_title(f'{name}: Option Deltas')
        ax2.set_xlabel('Time Step')
        ax2.set_ylabel('Delta')
        ax2.grid(True, alpha=0.3)
        
        # Print statistics
        print(f"{name} Options:")
        print(f"  Initial option price: {option_prices[0]:.6f}")
        print(f"  Final option price:   {option_prices[-1]:.6f}")
        print(f"  Mean delta: {np.mean(option_deltas):.4f}")
        print(f"  Delta range: [{np.min(option_deltas):.4f}, {np.max(option_deltas):.4f}]")
    
    plt.tight_layout()
    plt.show()

def train_and_compare_agents(worlds):
    """Train agents on different models and compare performance."""
    
    print("\nTraining agents on different models...")
    
    results = {}
    
    for name, world in worlds.items():
        print(f"\nTraining agent on {name} model...")
        
        # Create gym
        config = Config()
        config.gym.agent.features = ['price', 'time_left', 'spot']
        if world.nInst > 1:  # Has options
            config.gym.agent.features.extend(['call_price', 'call_delta'])
        config.gym.agent.network.depth = 2
        config.gym.agent.network.width = 16
        config.gym.objective.utility = "exp2"
        config.gym.objective.lmbda = 1.0
        
        config.train.epochs = 20  # Quick training for demo
        config.train.batch_size = 100
        config.output_level = "quiet"  # Reduce output
        
        gym = VanillaDeepHedgingGym(config.gym)
        val_world = world.clone(seed=54321, samples=500)
        
        # Train
        train(gym, world, val_world, config=config.train)
        
        # Test
        test_results = gym(val_world.tf_data)
        test_results_np = {key: val.numpy() if hasattr(val, 'numpy') else val 
                          for key, val in test_results.items()}
        
        results[name] = {
            'mean_utility': np.mean(test_results_np['utility']),
            'mean_pnl': np.mean(test_results_np['pnl']),
            'mean_cost': np.mean(test_results_np['cost']),
            'mean_gains': np.mean(test_results_np['gains']),
            'std_gains': np.std(test_results_np['gains'])
        }
        
        print(f"  Mean utility: {results[name]['mean_utility']:.6f}")
        print(f"  Mean gains: {results[name]['mean_gains']:.6f}")
    
    # Summary comparison
    print("\n" + "="*60)
    print("TRAINING RESULTS COMPARISON")
    print("="*60)
    print(f"{'Model':<15} {'Utility':<12} {'PnL':<10} {'Cost':<10} {'Gains':<10}")
    print("-" * 60)
    
    for name, res in results.items():
        print(f"{name:<15} {res['mean_utility']:<12.6f} {res['mean_pnl']:<10.4f} "
              f"{res['mean_cost']:<10.4f} {res['mean_gains']:<10.4f}")
    
    return results

def main():
    """Main execution function."""
    
    print("="*80)
    print("BACHELIER MODEL DEMONSTRATION")
    print("="*80)
    
    print("\nThe Bachelier model uses arithmetic Brownian motion:")
    print("  dS = μ dt + σ dW  (can go negative)")
    print("\nCompared to Black-Scholes geometric Brownian motion:")
    print("  dS = μS dt + σS dW  (always positive)")
    
    # Create worlds
    worlds = create_worlds_comparison()
    
    # Compare spot paths
    try:
        compare_spot_paths(worlds)
    except ImportError:
        print("Matplotlib not available for plotting")
    
    # Compare option pricing
    try:
        compare_option_pricing(worlds)
    except ImportError:
        print("Matplotlib not available for option pricing plots")
    
    # Train and compare agents
    results = train_and_compare_agents(worlds)
    
    print("\n" + "="*80)
    print("SUMMARY")
    print("="*80)
    print("\nKey differences observed:")
    print("1. Bachelier allows negative spot prices")
    print("2. Different option pricing formulas")
    print("3. Different Greeks (delta, vega)")
    print("4. Agent performance may vary between models")
    
    print("\nTo use Bachelier model in your code:")
    print("  config.bachelier = True")
    print("  world = SimpleWorld_Spot_ATM(config)")
    
    return worlds, results

if __name__ == "__main__":
    worlds, results = main()
    
    print("\n" + "="*80)
    print("EXAMPLE COMPLETED!")
    print("="*80)
    print("\nThe Bachelier model is now available in DeepHedging!")
    print("Use config.bachelier = True to enable it.") 